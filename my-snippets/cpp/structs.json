{
  "Struct Node": {
    "prefix": "struct",
    "body": [
      "struct Node {",
      "\t${1:int} ${2:x};",
      "\t${3:int} ${4:y};",
      "\t${5:int} ${6:z};",
      "\tNode(${1:int} ${2:x}, ${3:int} ${4:y}, ${5:int} ${6:z}) : ${2:x}(${2:x}), ${4:y}(${4:y}), ${6:z}(${6:z}) {}",
      "};",
      "$0"
    ],
    "description": "Create a node struct"
  },
  "Custom Heap": {
    "prefix": "custompq",
    "body": [
      "bool ${1:comp}(const Node &${2:x}, const Node &${3:y}) { return ${2:x}.val > ${3:y}.val; }",
      "priority_queue<Node, vector<Node>, decltype(&${1:comp})> ${4:pq}(&${1:comp});",
      "$0"
    ],
    "description": "Create a custom heap for complex data types"
  },
  "Min Heap": {
    "prefix": "minpq",
    "body": ["priority_queue<int> ${1:pq};", "$0"],
    "description": "Create a min heap for integers"
  },
  "Max Heap": {
    "prefix": "maxpq",
    "body": ["priority_queue<int, vector<int>, greater<int>> ${1:pq};", "$0"],
    "description": "Create a max heap for integers"
  },
  "DSU - Disjoint Set Union": {
    "prefix": "DSU",
    "body": [
      "class DSU {",
      "private:",
      "  int groupCount;",
      "  vector<int> parent;",
      "  vector<int> rank;",
      "  vector<int> groupSizes;",
      "",
      "public:",
      "  DSU(int n) {",
      "    groupCount = n;",
      "    parent.resize(n);",
      "    rank.resize(n, 0);",
      "    groupSizes.resize(n, 1);",
      "    for (int i = 0; i < n; ++i) {",
      "      parent[i] = i;",
      "    }",
      "  }",
      "",
      "  int find(int x) {",
      "    if (parent[x] != x) {",
      "      parent[x] = find(parent[x]);",
      "    }",
      "    return parent[x];",
      "  }",
      "",
      "  void join(int x, int y) {",
      "    int rootX = find(x);",
      "    int rootY = find(y);",
      "    if (rootX == rootY) {",
      "      return;",
      "    }",
      "    if (rank[rootX] < rank[rootY]) {",
      "      parent[rootX] = rootY;",
      "      groupSizes[rootY] += groupSizes[rootX];",
      "    } else if (rank[rootX] > rank[rootY]) {",
      "      parent[rootY] = rootX;",
      "      groupSizes[rootX] += groupSizes[rootY];",
      "    } else {",
      "      parent[rootY] = rootX;",
      "      rank[rootX]++;",
      "      groupSizes[rootX] += groupSizes[rootY];",
      "    }",
      "    groupCount--;",
      "  }",
      "",
      "  int groupSize(int x) {",
      "    int root = find(x);",
      "    return groupSizes[root];",
      "  }",
      "",
      "  vector<int> groupElements(int x) {",
      "    vector<int> elements;",
      "    int root = find(x);",
      "    for (int i = 0; i < parent.size(); ++i) {",
      "      if (find(i) == root) {",
      "        elements.push_back(i);",
      "      }",
      "    }",
      "    return elements;",
      "  }",
      "};",
      "$0"
    ],
    "description": "Create a max heap for integers"
  }
}
